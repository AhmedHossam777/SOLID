# SOLID Principles with TypeScript Examples

This repository contains examples that demonstrate the SOLID principles using TypeScript. The SOLID principles are a set of design principles that help in creating more maintainable, understandable, and flexible software. Each principle is illustrated with a code example.

## Table of Contents

- [SOLID Principles with TypeScript Examples](#solid-principles-with-typescript-examples)
  - [Table of Contents](#table-of-contents)
  - [Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)
  - [Open/Closed Principle (OCP)](#openclosed-principle-ocp)
  - [Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)
  - [Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)
  - [Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)
  - [Usage](#usage)
  - [Contributing](#contributing)

## Single Responsibility Principle (SRP)

A class should have only one reason to change, meaning it should have only one job or responsibility.

## Open/Closed Principle (OCP)

Software entities should be open for extension but closed for modification.

## Liskov Substitution Principle (LSP)

Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

## Interface Segregation Principle (ISP)

Clients should not be forced to depend on interfaces they do not use.

## Dependency Inversion Principle (DIP)

High-level modules should not depend on low-level modules. Both should depend on abstractions.

## Usage

Each principle is demonstrated in a separate TypeScript file within this repository. Clone the repository and explore the examples to understand how each principle can be applied in practice.

```bash
git clone https://github.com/AhmedHossam777/SOLID
cd solid-principles-typescript
```

## Contributing

Contributions are welcome! Feel free to submit a pull request or open an issue if you have suggestions for improvements or additional examples.
